<!DOCTYPE html>
<html>
<!--
Copyright 2011 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<head>
<title>observeElement and observeAttribute Tests</title>
<script src="../third_party/closure/closure/goog/base.js"></script>
<script src="compat.js"></script>
<script src="weak_map.js"></script>
<script src="forwarding_handler.js"></script>
<script src="object_observe.js"></script>
<script src="events.js"></script>
<script src="aspect_work_queue.js"></script>
<script src="dom_observe.js"></script>
<script>
goog.require('goog.testing.jsunit');
</script>
</head>
<body>
<script>

function assertNextMutationIs(expected, log) {
  var mutation = log.clear()[0];
  if (!expected) {
    assertUndefined('mutation exists', mutation);
    return;
  }

  assertTrue('mutation does not exist', !!mutation);

  var count = 0;
  for (prop in expected) {
    if (Array.isArray(expected[prop]) && Array.isArray(mutation[prop])) {
      assertArrayEquals('mutation prop ' + prop,
                        expected[prop], mutation[prop]);
    } else {
      assertEquals('mutation prop ' + prop, expected[prop], mutation[prop]);
    }
    count++;
  }

  assertEquals(count, Object.keys(mutation).length);
}

function browserSupportsAttributes() {
  var el = document.createElement('div');
  var sendsAttributeEvents = false;
  function attributeEventDetector(event) {
    sendsAttributeEvents = true;
  }
  el.addEventListener('DOMAttrModified', attributeEventDetector, false);
  el.setAttribute('id', 'foo');
  return sendsAttributeEvents;
}

function testAttributeChanged() {
  if (!browserSupportsAttributes()) return;

  var log = new MutationLog;
  document.observeAttribute('span', 'id', log);
  var span = document.createElement('span');
  document.body.appendChild(span);
  // Adding an element and setting an attribute
  // should cause the attribute setting to be swallowed.
  span.id = 'default';
  AspectWorkQueue.runUntilEmpty();
  assertEquals(0, log.length);

  // Two sets should be collapsed into one.
  span.id = 'hell';
  span.id = 'hello';
  AspectWorkQueue.runUntilEmpty();
  assertEquals(1, log.length);
  assertNextMutationIs({
    type: 'AttributeChanged',
    element: span,
    attribute: 'id'
  }, log);

  span.id = 'goodbye';
  // Removing, then adding, should be ignored.
  document.body.removeChild(span);
  document.body.appendChild(span);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(1, log.length);
  assertNextMutationIs({
    type: 'AttributeChanged',
    element: span,
    attribute: 'id'
  }, log);

  span.removeAttribute('id');
  AspectWorkQueue.runUntilEmpty();
  assertEquals(1, log.length);
  assertNextMutationIs({
    type: 'AttributeChanged',
    element: span,
    attribute: 'id'
  }, log);

  document.body.removeChild(span);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(0, log.length);

  var div = document.createElement('div');
  div.appendChild(span);
  document.body.appendChild(div);
  span.id = 'helloAgain';
  AspectWorkQueue.runUntilEmpty();
  assertEquals(0, log.length);

  span.id = 'modification';
  document.body.removeChild(div);
  document.body.appendChild(div);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(1, log.length);
  assertNextMutationIs({
    type: 'AttributeChanged',
    element: span,
    attribute: 'id'
  }, log);

  document.stopObservingAttribute('span', 'id', log);
  span.id = 'shouldnotbeobserved';
  AspectWorkQueue.runUntilEmpty();
  assertEquals(0, log.length);

  document.body.removeChild(div);
}

function testAttributeChangedNotFiredOnRemove() {
  if (!browserSupportsAttributes()) return;

  var log = new MutationLog;
  document.observeAttribute('span', 'id', log);
  var div = document.createElement('div');
  var span = document.createElement('span');
  div.appendChild(span);
  document.body.appendChild(div);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(0, log.length);

  div.removeChild(span);
  span.id = 'hello';
  AspectWorkQueue.runUntilEmpty();
  assertEquals(0, log.length);

  div.appendChild(span);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(0, log.length);

  span.id = 'goodbye';
  document.body.removeChild(div);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(0, log.length);
}

function testElementMutations() {
  var log = new MutationLog;
  document.observeElement('span', log);
  var span = document.createElement('span');
  var div = document.createElement('div');
  div.appendChild(span);
  document.body.appendChild(div);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(1, log.length);
  assertNextMutationIs({
    type: 'ElementAdded',
    element: span,
  }, log);

  div.removeChild(span);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(1, log.length);
  assertNextMutationIs({
    type: 'ElementRemoved',
    element: span,
  }, log);

  document.stopObservingElement('span', log);
  div.appendChild(span);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(0, log.length);

  document.body.removeChild(div);
}

function testSubtreeRemovalBehavior() {
  var log = new MutationLog;
  document.observeElement('span', log);
  var div1 = document.createElement('div');
  var div2 = document.createElement('div');
  var span = document.createElement('span');
  div1.appendChild(div2);
  div2.appendChild(span);
  document.body.appendChild(div1);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(1, log.length);
  assertNextMutationIs({
    type: 'ElementAdded',
    element: span
  }, log);

  document.body.removeChild(div1);
  // This add will be ignored since this is a detached subtree.
  div1.appendChild(document.createElement('span'));
  div1.removeChild(div2);
  div2.removeChild(span);
  // This add will be ignored because it was previously
  // marked as a "remove" (when div1 is queried for its descendants).
  div1.appendChild(document.createElement('span'));
  AspectWorkQueue.runUntilEmpty();
  assertEquals(1, log.length);
  assertNextMutationIs({
    type: 'ElementRemoved',
    element: span
  }, log);
}

function testSubtreeMoveBehavior() {
  var log = new MutationLog;
  document.observeElement('span', log);
  var div = document.createElement('div');
  document.body.appendChild(div);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(0, log.length);

  document.body.removeChild(div);
  var span = document.createElement('span');
  div.appendChild(span);
  document.body.appendChild(div);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(1, log.length);
  assertNextMutationIs({
    type: 'ElementAdded',
    element: span
  }, log);
}

function testSubtreeMoveBehavior2() {
  var log = new MutationLog;
  document.observeElement('span', log);
  var div = document.createElement('div');
  var span = document.createElement('span');
  document.body.appendChild(div);
  document.body.appendChild(span);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(1, log.length);
  assertNextMutationIs({
    type: 'ElementAdded',
    element: span
  }, log);

  document.body.removeChild(span);
  var div2 = div.appendChild(document.createElement('div'));
  div2.appendChild(span);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(0, log.length);
}

function testAddingToDetachedSubtree() {
  var log = new MutationLog;
  document.observeElement('b', log);
  var div = document.createElement('div');
  document.body.appendChild(div);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(0, log.length);

  var span = document.createElement('span');
  var b = document.createElement('b');
  document.body.removeChild(div);
  div.appendChild(span);
  span.appendChild(b);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(0, log.length);
}

function testRemoveThenAddElsewhere() {
  var div1 = document.createElement('div');
  var div2 = document.createElement('div');
  var span = document.createElement('span');
  div1.appendChild(span);
  div1.appendChild(div2);
  document.body.appendChild(div1);

  var log = new MutationLog;
  document.observeElement('span', log);
  div1.removeChild(span);
  div1.removeChild(div2);
  div2.appendChild(span);
  AspectWorkQueue.runUntilEmpty();
  assertEquals(1, log.length);
  assertNextMutationIs({
    type: 'ElementRemoved',
    element: span
  }, log);
}

</script>
</body>
</html>
