<!DOCTYPE html>
<html>
<!--
Copyright 2011 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<head>
<title>Object Observe Tests</title>
<script src="third_party/closure/closure/goog/base.js"></script>
<script src="compat.js"></script>
<script src="forwarding_handler.js"></script>
<script src="weak_map.js"></script>
<script src="object_observe.js"></script>

<script>
goog.require('goog.testing.jsunit');
</script>
</head>
<body>

<script>
// Closure's assertArrayEquals does not handle proxies
function assertArrayEquals() {
  var msg = '', a, b;
  if (arguments.length == 3)
    [msg, a, b] = arguments;
  else
    [a, b] = arguments;
  assertEquals('different type', typeof a, typeof b);
  assertEquals('different length', a.length, b.length);
  for (var i = 0; i < a.length; i++) {
    assertEquals('index ' + i, a[i], b[i]);
  }
}

function assertNextMutationIs(expected, log) {
  var mutation = log.next();
  if (!expected) {
    assertUndefined('mutation exists', mutation);
    return;
  }

  assertTrue('mutation does not exist', !!mutation);

  var count = 0;
  for (prop in expected) {
    assertEquals('mutation prop ' + prop, expected[prop], mutation[prop]);
    count++;
  }

  assertEquals(count, Object.keys(mutation).length);
}

function testEvent() {
  var data = { id: 1 };
  var model = Object.getObservable(data);
  var log = new MutationLog();

  Object.observe(model, log);

  // Mutation should be logged.
  model.id = 2;
  assertEquals(1, log.length);
  assertEquals(model.id, data.id);

  // Event shouldn't fire, but model & data should still agree.
  data.id = 3;
  assertEquals(1, log.length);
  assertEquals(model.id, data.id);
}

function testBasic() {
  var data = {};
  var model = Object.getObservable(data);
  var log = new MutationLog();

  Object.observe(model, log);

  model.id = 0;
  assertNextMutationIs({
    mutation: 'set',
    name: 'id',
    target: model
  }, log);

  model.id = -1;
  assertNextMutationIs({
    mutation: 'set',
    name: 'id',
    target: model
  }, log);

  delete model.id;
  assertNextMutationIs({
    mutation: 'delete',
    name: 'id',
    target: model
  }, log);

  // Stop observing -- shouldn't see an event.
  Object.stopObserving(model, log);

  model.id = 101;
  assertNextMutationIs(undefined, log);

  // Re-observe -- should see an new event again.
  Object.observe(model, log);

  model.id = 100;
  assertNextMutationIs({
    mutation: 'set',
    name: 'id',
    target: model
  }, log);
}

function testIdentity() {
  var obj = {};
  var m1 = Object.getObservable(obj);
  var m2 = Object.getObservable(obj);
  assertTrue(m1 === m2);
}

function testIdentity2() {
  var obj = {a: {}, b: {}};
  var m1 = Object.getObservable(obj);
  var c = m1.a.c = {};
  delete m1.a.c;
  var m2 = m1.a;
  m2.c = c;
  assertTrue(m1.a.c === m2.c);
}

function testMultipleObservationsAreCollapsed() {
  var m = Object.getObservable({id: 1});
  var log = new MutationLog();

  Object.observe(m, log);
  Object.observe(m, log);

  m.id = 2;
  assertEquals(1, log.length);
}

function testModelWithFunctions() {
  var object = {
    innerObject: {},
    field: 42,
    method1: function() {
      return this.field;
    },
    method2: function() {
      return 42;
    },
    getInnerObject: function() {
      return this.innerObject;
    },

    modifyField: function() {
      // "this" is not wrapped
      assertEquals(object, this);
      this.field++;
    }
  };
  var m = Object.getObservable(object);

  assertEquals(42, m.field);
  assertEquals(42, m.method1());
  assertEquals(42, m.method2());

  var g = m.method1.bind(m);
  assertEquals('Test that bind works correctly', 42, g());

  var f = m.method2;
  assertEquals(42, f());

  var log = new MutationLog();
  Object.observe(f, log);
  f.test = 1;
  assertNextMutationIs({
    mutation: 'set',
    name: 'test',
    target: f
  }, log);

  Object.observe(m, log);
  m.modifyField();
  assertNextMutationIs(undefined, log);

  var innerObject = m.getInnerObject();
  Object.observe(innerObject, log);

  assertEquals('Ensure that we return wrapped objects',
               m.innerObject, innerObject);

  innerObject.x = 'y';
  assertNextMutationIs({
    mutation: 'set',
    name: 'x',
    target: innerObject
  }, log);
}

function testModelFunctionConstruct() {
  var m = Object.getObservable(function(x, y, z) {
    assertEquals('x', x);
    assertEquals('y', y);
    assertEquals('z', z);

    this.change = function() {
      this.test++;
    };

    var self = this;
    this.change2 = function() {
      self.test++;
    };

    this.change3 = function(obj) {
      this.test += Number(obj !== Object.getObservable(obj));
    }
  });

  var object = new m('x', 'y', 'z');

  var log = new MutationLog();
  Object.observe(object, log);
  object.test = 1;
  assertNextMutationIs({
    mutation: 'set',
    name: 'test',
    target: object
  }, log);

  // "this" is not wrapped
  object.change();
  assertEquals(2, object.test);
  assertNextMutationIs(undefined, log);


  // Internal change not observable.
  object.change2();
  assertEquals(3, object.test);
  assertNextMutationIs(undefined, log);


  // Arguments should be unwrapped.
  object.change3(Object.getObservable({}));
  assertEquals(4, object.test);
  assertNextMutationIs(undefined, log);
}

function testModelFunctionConstructReturnObject() {
  var m = Object.getObservable(function(x, y, z) {
    assertEquals('x', x);
    assertEquals('y', y);
    assertEquals('z', z);

    return {returned: true};
  });

  var object = new m('x', 'y', 'z');
  assertTrue(object.returned);

  var log = new MutationLog();
  Object.observe(object, log);
  object.test = 1;
  assertNextMutationIs({
    mutation: 'set',
    name: 'test',
    target: object
  }, log);
}

function testInstanceOf() {
  var n = Object.getObservable(new Number(42));
  assertTrue(n instanceof Number);

  function MyClass() {};

  var F = Object.getObservable(MyClass);
  assertTrue(F instanceof Function);

  var o = new F;
  assertTrue(o instanceof MyClass);
}

function testArrayModel() {
  var zero = {zero: 0};
  var one = {one: 1};
  var m = Object.getObservable([zero, one]);

  var log = new MutationLog();
  Object.observe(m, log);

  var two = {two: 2};
  var three = {three: 3};

  m[0] = two;
  assertArrayEquals(Object.getObservable([two, one]), m);
  assertNextMutationIs({
    mutation: 'set',
    name: '0',
    target: m
  }, log);

  m[1] = three;
  assertArrayEquals(Object.getObservable([two, three]), m);
  assertNextMutationIs({
    mutation: 'set',
    name: '1',
    target: m
  }, log);
}

function testArrayModelSplice() {
  var zero = {zero: 'zero'};
  var one = {one: 'one'};
  var two = {two: 'two'};
  var three = {three: 'three'};
  var zeroModel = Object.getObservable(zero);
  var oneModel = Object.getObservable(one);
  var twoModel = Object.getObservable(two);
  var threeModel = Object.getObservable(three);

  var arr = [zero, one];
  var m = Object.getObservable(arr);

  var expected = {};
  var log = new MutationLog();
  Object.observe(m, log);

  m.splice(1, 1, two, three);
  assertArrayEquals([zero, two, three], arr);
  assertArrayEquals([zeroModel, twoModel, threeModel], m);

  assertNextMutationIs({
    mutation: 'splice',
    index: 1,
    deleteCount: 1,
    addCount: 2,
    target: m
  }, log);

  m.splice(0, 1);

  assertArrayEquals([two, three], arr);
  assertArrayEquals([twoModel, threeModel], m);

  assertNextMutationIs({
    mutation: 'splice',
    index: 0,
    deleteCount: 1,
    addCount: 0,
    target: m
  }, log);

  m.splice();
  assertNextMutationIs(undefined, log);

  m.splice(0, 0);
  assertNextMutationIs(undefined, log);

  m.splice(0, -1);
  assertNextMutationIs(undefined, log);

  m.splice(-1, 0, 1.5);
  assertArrayEquals([two, 1.5, three], arr);
  assertArrayEquals([twoModel, 1.5, threeModel], m);

  assertNextMutationIs({
    mutation: 'splice',
    index: 1,
    deleteCount: 0,
    addCount: 1,
    target: m
  }, log);

  m.splice(3, 0, zeroModel);
  assertArrayEquals([two, 1.5, three, zero], arr);
  assertArrayEquals([twoModel, 1.5, threeModel, zeroModel], m);

  assertNextMutationIs({
    mutation: 'splice',
    index: 3,
    deleteCount: 0,
    addCount: 1,
    target: m
  }, log);

 m.splice(0);
 assertNextMutationIs({
   mutation: 'splice',
   index: 0,
   deleteCount: 4,
   addCount: 0,
   target: m
 }, log);
}

function testArrayModelLength() {
  var m = Object.getObservable([0, 1]);

  var log = new MutationLog();
  Object.observe(m, log);

  m.length = 5;
  assertArrayEquals([0, 1, , , ,], m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 2,
    deleteCount: 0,
    addCount: 3,
    target: m
  }, log);

  m.length = 1;
  assertArrayEquals([0], m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 1,
    deleteCount: 4,
    addCount: 0,
    target: m
  }, log);

  m.length = 1;
  assertArrayEquals([0], m);
  assertNextMutationIs({
    mutation: 'set',
    name: 'length',
    target: m
  }, log);
}


function testArrayModelPush() {
  var zero = {zero: 0};
  var one = {one: 1};
  var m = Object.getObservable([zero, one]);

  var log = new MutationLog();
  Object.observe(m, log);

  var two = {two: 2};
  var three = {three: 3};

  m.push(two, three);
  assertArrayEquals(Object.getObservable([zero, one, two, three]), m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 2,
    deleteCount: 0,
    addCount: 2,
    target: m
  }, log);

  m.push();
  assertNextMutationIs(undefined, log);

}

function testArrayModelPop() {
  var zero = {zero: 0};
  var one = {one: 1};
  var m = Object.getObservable([zero, one]);

  var log = new MutationLog();
  Object.observe(m, log);

  assertEquals(Object.getObservable(one), m.pop());
  assertArrayEquals([Object.getObservable(zero)], m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 1,
    deleteCount: 1,
    addCount: 0,
    target: m
  }, log);

  assertEquals(Object.getObservable(zero), m.pop());
  assertArrayEquals([], m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 0,
    deleteCount: 1,
    addCount: 0,
    target: m
  }, log);

  assertUndefined,(m.pop());
  assertArrayEquals([], m);
  assertNextMutationIs(undefined, log);
}

function testArrayModelShift() {
  var zero = {zero: 0};
  var one = {one: 1};
  var m = Object.getObservable([zero, one]);

  var log = new MutationLog();
  Object.observe(m, log);

  assertEquals(Object.getObservable(zero), m.shift());
  assertArrayEquals([Object.getObservable(one)], m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 0,
    deleteCount: 1,
    addCount: 0,
    target: m
  }, log);

  assertEquals(Object.getObservable(one), m.shift());
  assertArrayEquals([], m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 0,
    deleteCount: 1,
    addCount: 0,
    target: m
  }, log);

  assertUndefined,(m.shift());
  assertArrayEquals([], m);
  assertNextMutationIs(undefined, log);
}

function testArrayModelUnshift() {
  var zero = {zero: 0};
  var one = {one: 1};
  var m = Object.getObservable([zero, one]);

  var log = new MutationLog();
  Object.observe(m, log);

  var negOne = {negOne: -1};

  assertEquals(3, m.unshift(negOne));
  assertArrayEquals(Object.getObservable([negOne, zero, one]), m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 0,
    deleteCount: 0,
    addCount: 1,
    target: m
  }, log);

  var negTwo = {negTwo: -2};
  var negThree = {negThree: -3};

  assertEquals(5, m.unshift(negThree, negTwo));
  assertArrayEquals(Object.getObservable([negThree, negTwo, negOne, zero, one]),
                    m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 0,
    deleteCount: 0,
    addCount: 2,
    target: m
  }, log);

  assertUndefined,(m.unshift());
  assertArrayEquals(Object.getObservable([negThree, negTwo, negOne, zero, one]),
                    m);
  assertNextMutationIs(undefined, log);
}

function testArrayModelIndexOf() {
  var zero = {zero: 0};
  var one = {one: 1};
  var m = Object.getObservable([zero, one]);
  var zeroModel = m[0];
  var oneModel = m[1];

  assertEquals(0, m.indexOf(zero));
  assertEquals(0, m.indexOf(zeroModel));
  assertEquals(1, m.indexOf(one));
  assertEquals(1, m.indexOf(oneModel));
  assertEquals(-1, m.indexOf({foo: 'bar'}));
}

</script>
</body>
</html>
