<!DOCTYPE html>
<html>
<!--
Copyright 2011 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<head>
<title>Object Observe Tests</title>
<script src="third_party/closure/closure/goog/base.js"></script>
<script src="compat.js"></script>
<script src="forwarding_handler.js"></script>
<script src="weak_map.js"></script>
<script src="object_observe.js"></script>

<script>
goog.require('goog.testing.jsunit');
</script>
</head>
<body>

<script>

function newSpliceMutation(index, deleteCount, addCount, target) {
  return {
    mutation: 'splice',
    index: index,
    deleteCount: deleteCount,
    addCount: addCount,
    target: target
  }
}

function intersect(start1, end1, start2, end2) {
  if (start1 > end1 || start2 > end2)
    throw Error('Invalid splice range provided: ' +
                [start1, end1, start2, end2].join(', '));

  // Disjoint
  if (end1 < start2 || end2 < start1)
    return -1;

  // Adjacent
  if (end1 == start2 || end2 == start1)
    return 0;

  // Non-zero intersect, span1 first
  if (start1 < start2) {
    if (end1 < end2)
      return end1 - start2; // Overlap
    else
      return end2 - start2; // Contained
  } else {
    // Non-zero intersect, span2 first
    if (end2 < end1)
      return end2 - start1; // Overlap
    else
      return end1 - start1; // Contained
  }
}

function isIndex(s) {
  // toUint32: s >>> 0
  return +s === s >>> 0;
}

function ArrayTracker(target) {
  this.target = target;
  this.copy = target.concat();
  this.virtualLength = this.copy.length;
}

ArrayTracker.prototype = {
  addMutation: function(mutation) {
    if (this.target && mutation.target !== this.target)
      return;
    if (!this.splices)
      this.splices = [];

    var splice;
    if (mutation.mutation == 'set' || mutation.mutation == 'delete') {
      if (!isIndex(mutation.name))
        return;

      var index = +mutation.name;
      if (mutation.mutation == 'delete' && index >= this.virtualLength)
        return;

      splice = newSpliceMutation(index, 1, 1, mutation.target);
    } else {
      splice = newSpliceMutation(mutation.index,
                                 mutation.deleteCount,
                                 mutation.addCount,
                                 mutation.target);
    }

    var range = splice.index + splice.deleteCount;
    var delta = splice.addCount - splice.deleteCount;
    var inserted = false;

    for (var i = 0; i < this.splices.length; i++) {
      var current = this.splices[i];
      var currentRange = current.index + current.addCount;
      var intersectCount = intersect(splice.index,
                                     range,
                                     current.index,
                                     currentRange);

      if (intersectCount >= 0) {
        // Merge the two splices
        splice.index = Math.min(splice.index, current.index);
        splice.deleteCount = splice.deleteCount +
                             current.deleteCount -
                             intersectCount;
        splice.addCount = splice.addCount +
                          current.addCount -
                          intersectCount;
        this.splices.splice(i, 1);
        i--;
      } else if (splice.index <= current.index) {
        current.index += delta;
        if (!inserted) {
          // Insert splice here.
          this.splices.splice(i, 0, splice);
          i++;
          inserted = true;
        }
      }
    }

    if (!inserted)
      this.splices.push(splice);

    this.virtualLength += delta;
  },

  notify: function() {
    this.splices.forEach(function(splice) {
      var spliceArgs = [splice.index, splice.deleteCount];
      var addIndex = splice.index;
      while (addIndex < splice.index + splice.addCount) {
        spliceArgs.push(this.target[addIndex]);
        addIndex++;
      }

      Array.prototype.splice.apply(this.copy, spliceArgs);
    }, this);
  }
}

function assertArrayTracker(tracker, log) {
  log.clear().forEach(function(mutation) {
    tracker.addMutation(mutation);
  });

  tracker.notify();
  assertArrayEquals(tracker.target, tracker.copy);
}

function testSpliceContained() {
  var data = ['a', 'b'];
  var m = Object.getObservable(data);
  var tracker = new ArrayTracker(m);
  var log = new MutationLog();
  Object.observe(m, log);

  m.splice(1, 1);
  m.unshift('c', 'd', 'e');
  m.splice(1, 2, 'f');

  assertArrayTracker(tracker, log);
}

function testSpliceDeleteEmpty() {
  var data = [];
  var m = Object.getObservable(data);
  var tracker = new ArrayTracker(m);
  var log = new MutationLog();
  Object.observe(m, log);

  delete m[0];
  m.splice(0, 0, 'a', 'b', 'c');

  assertArrayTracker(tracker, log);
}

function testArrayTrackerRightNonOverlap() {
  var data = ['a', 'b', 'c', 'd'];
  var m = Object.getObservable(data);
  var tracker = new ArrayTracker(m);
  var log = new MutationLog();
  Object.observe(m, log);

  m.splice(0, 1, 'e');
  m.splice(2, 1, 'f', 'g');
  assertArrayTracker(tracker, log);
}

function testArrayTrackerLeftNonOverlap() {
  var data = ['a', 'b', 'c', 'd'];
  var m = Object.getObservable(data);
  var tracker = new ArrayTracker(m);
  var log = new MutationLog();
  Object.observe(m, log);

  m.splice(3, 1, 'f', 'g');
  m.splice(0, 1, 'e');
  assertArrayTracker(tracker, log);
}

function testArrayTrackerRightAdjacent() {
  var data = ['a', 'b', 'c', 'd'];
  var m = Object.getObservable(data);
  var tracker = new ArrayTracker(m);
  var log = new MutationLog();
  Object.observe(m, log);

  m.splice(1, 1, 'e');
  m.splice(2, 1, 'f', 'g');
  assertArrayTracker(tracker, log);
}

function testArrayTrackerLeftAdjacent() {
  var data = ['a', 'b', 'c', 'd'];
  var m = Object.getObservable(data);
  var tracker = new ArrayTracker(m);
  var log = new MutationLog();
  Object.observe(m, log);

  m.splice(2, 2, 'e');
  m.splice(1, 1, 'f', 'g');
  assertArrayTracker(tracker, log);
}

function testArrayTrackerRightOverlap() {
  var data = ['a', 'b', 'c', 'd'];
  var m = Object.getObservable(data);
  var tracker = new ArrayTracker(m);
  var log = new MutationLog();
  Object.observe(m, log);

  m.splice(1, 1, 'e');
  m.splice(1, 1, 'f', 'g');
  assertArrayTracker(tracker, log);
}

function testArrayTrackerLeftOverlap() {
  var data = ['a', 'b', 'c', 'd'];
  var m = Object.getObservable(data);
  var tracker = new ArrayTracker(m);
  var log = new MutationLog();
  Object.observe(m, log);

  m.splice(2, 1, 'e', 'f', 'g');  // a b [e f g] d
  m.splice(1, 2, 'h', 'i', 'j'); // a [h i j] f g d
  assertArrayTracker(tracker, log);
}

function testArrayTrackerUpdateDelete() {
  var data = ['a', 'b', 'c', 'd'];
  var m = Object.getObservable(data);
  var tracker = new ArrayTracker(m);
  var log = new MutationLog();
  Object.observe(m, log);

  m.splice(2, 1, 'e', 'f', 'g');  // a b [e f g] d
  m[0] = 'h';
  delete m[1];
  assertArrayTracker(tracker, log);
}

var valMax = 10;
var arrayLengthMax = 10;

function randInt(start, end) {
  return Math.round(Math.random()*(end-start) + start);
}

function randArray() {

  var args = [];
  var count = randInt(0, arrayLengthMax);

  while(count-- > 0) {
    args.push(randInt(0, valMax));
  }

  return args;
}

function randomArrayOperation(arr) {
  function empty() {
    return [];
  }

  var operations = {
    push: randArray,
    unshift: randArray,
    pop: empty,
    shift: empty,
    splice: function() {
      var args = [];
      args.push(randInt(-arr.length*2, arr.length*2), randInt(0, arr.length*2));
      args = args.concat(randArray());
      return args;
    }
  };

  // Do a splice once for each of the other operations.
  var operationList = ['splice', 'update',
                       'splice', 'delete',
                       'splice', 'push',
                       'splice', 'pop',
                       'splice', 'shift',
                       'splice', 'unshift'];

  var operation = operationList[randInt(0, operationList.length - 1)];
  if (operation == 'delete') {
    var index = randInt(0, arr.length - 1);
    delete arr[index];
  } else if (operation == 'update') {
    arr[randInt(0, arr.length - 1)] = randInt(0, valMax);
  } else {
    var opArgs = operations[operation]();
    Array.prototype[operation].apply(arr, opArgs);
  }
}

function randomArrayOperations(arr, count) {
  for (var i = 0; i < count; i++) {
    randomArrayOperation(arr);
  }
}

var testCount = 128;
var operationCount = 128;

function testSpliceFuzzer() {
  console.log('Fuzzing spliceProjection ' + testCount +
              ' passes with ' + operationCount + ' operations each.');
  for (var i = 0; i < testCount; i++) {
    var data = []; randArray();
    var m = Object.getObservable(data);
    var tracker = new ArrayTracker(m);
    var log = new MutationLog();
    Object.observe(m, log);

    //  console.log('initial: ' + data.join(', '));

    Object.observe(m, log);
    randomArrayOperations(m, operationCount);

    assertArrayTracker(tracker, log);
  }
}

// Closure's assertArrayEquals does not handle proxies
function assertArrayEquals() {
  var msg = '', a, b;
  if (arguments.length == 3)
    [msg, a, b] = arguments;
  else
    [a, b] = arguments;
  assertEquals('different type', typeof a, typeof b);
  assertEquals('different length', a.length, b.length);
  for (var i = 0; i < a.length; i++) {
    assertEquals('index ' + i, a[i], b[i]);
  }
}

function assertNextMutationIs(expected, log) {
  var mutation = log.next();
  if (!expected) {
    assertUndefined('mutation exists', mutation);
    return;
  }

  assertTrue('mutation does not exist', !!mutation);

  var count = 0;
  for (prop in expected) {
    assertEquals('mutation prop ' + prop, expected[prop], mutation[prop]);
    count++;
  }

  assertEquals(count, Object.keys(mutation).length);
}

function testEvent() {
  var data = { id: 1 };
  var model = Object.getObservable(data);
  var log = new MutationLog();

  Object.observe(model, log);

  // Mutation should be logged.
  model.id = 2;
  assertEquals(1, log.length);
  assertEquals(model.id, data.id);

  // Event shouldn't fire, but model & data should still agree.
  data.id = 3;
  assertEquals(1, log.length);
  assertEquals(model.id, data.id);
}

function testBasic() {
  var data = {};
  var model = Object.getObservable(data);
  var log = new MutationLog();

  Object.observe(model, log);

  model.id = 0;
  assertNextMutationIs({
    mutation: 'set',
    name: 'id',
    target: model
  }, log);

  model.id = -1;
  assertNextMutationIs({
    mutation: 'set',
    name: 'id',
    target: model
  }, log);

  delete model.id;
  assertNextMutationIs({
    mutation: 'delete',
    name: 'id',
    target: model
  }, log);

  // Stop observing -- shouldn't see an event.
  Object.stopObserving(model, log);

  model.id = 101;
  assertNextMutationIs(undefined, log);

  // Re-observe -- should see an new event again.
  Object.observe(model, log);

  model.id = 100;
  assertNextMutationIs({
    mutation: 'set',
    name: 'id',
    target: model
  }, log);
}

function testIdentity() {
  var obj = {};
  var m1 = Object.getObservable(obj);
  var m2 = Object.getObservable(obj);
  assertTrue(m1 === m2);
}

function testIdentity2() {
  var obj = {a: {}, b: {}};
  var m1 = Object.getObservable(obj);
  var c = m1.a.c = {};
  delete m1.a.c;
  var m2 = m1.a;
  m2.c = c;
  assertTrue(m1.a.c === m2.c);
}

function testMultipleObservationsAreCollapsed() {
  var m = Object.getObservable({id: 1});
  var log = new MutationLog();

  Object.observe(m, log);
  Object.observe(m, log);

  m.id = 2;
  assertEquals(1, log.length);
}

function testModelWithFunctions() {
  var object = {
    innerObject: {},
    field: 42,
    method1: function() {
      return this.field;
    },
    method2: function() {
      return 42;
    },
    getInnerObject: function() {
      return this.innerObject;
    },

    modifyField: function() {
      // "this" is not wrapped
      assertEquals(object, this);
      this.field++;
    }
  };
  var m = Object.getObservable(object);

  assertEquals(42, m.field);
  assertEquals(42, m.method1());
  assertEquals(42, m.method2());

  var g = m.method1.bind(m);
  assertEquals('Test that bind works correctly', 42, g());

  var f = m.method2;
  assertEquals(42, f());

  var log = new MutationLog();
  Object.observe(f, log);
  f.test = 1;
  assertNextMutationIs({
    mutation: 'set',
    name: 'test',
    target: f
  }, log);

  Object.observe(m, log);
  m.modifyField();
  assertNextMutationIs(undefined, log);

  var innerObject = m.getInnerObject();
  Object.observe(innerObject, log);

  assertEquals('Ensure that we return wrapped objects',
               m.innerObject, innerObject);

  innerObject.x = 'y';
  assertNextMutationIs({
    mutation: 'set',
    name: 'x',
    target: innerObject
  }, log);
}

function testModelFunctionConstruct() {
  var m = Object.getObservable(function(x, y, z) {
    assertEquals('x', x);
    assertEquals('y', y);
    assertEquals('z', z);

    this.change = function() {
      this.test++;
    };

    var self = this;
    this.change2 = function() {
      self.test++;
    };

    this.change3 = function(obj) {
      this.test += Number(obj !== Object.getObservable(obj));
    }
  });

  var object = new m('x', 'y', 'z');

  var log = new MutationLog();
  Object.observe(object, log);
  object.test = 1;
  assertNextMutationIs({
    mutation: 'set',
    name: 'test',
    target: object
  }, log);

  // "this" is not wrapped
  object.change();
  assertEquals(2, object.test);
  assertNextMutationIs(undefined, log);


  // Internal change not observable.
  object.change2();
  assertEquals(3, object.test);
  assertNextMutationIs(undefined, log);


  // Arguments should be unwrapped.
  object.change3(Object.getObservable({}));
  assertEquals(4, object.test);
  assertNextMutationIs(undefined, log);
}

function testModelFunctionConstructReturnObject() {
  var m = Object.getObservable(function(x, y, z) {
    assertEquals('x', x);
    assertEquals('y', y);
    assertEquals('z', z);

    return {returned: true};
  });

  var object = new m('x', 'y', 'z');
  assertTrue(object.returned);

  var log = new MutationLog();
  Object.observe(object, log);
  object.test = 1;
  assertNextMutationIs({
    mutation: 'set',
    name: 'test',
    target: object
  }, log);
}

function testInstanceOf() {
  var n = Object.getObservable(new Number(42));
  assertTrue(n instanceof Number);

  function MyClass() {};

  var F = Object.getObservable(MyClass);
  assertTrue(F instanceof Function);

  var o = new F;
  assertTrue(o instanceof MyClass);
}

function testArrayModel() {
  var zero = {zero: 0};
  var one = {one: 1};
  var m = Object.getObservable([zero, one]);

  var log = new MutationLog();
  Object.observe(m, log);

  var two = {two: 2};
  var three = {three: 3};

  m[0] = two;
  assertArrayEquals(Object.getObservable([two, one]), m);
  assertNextMutationIs({
    mutation: 'set',
    name: '0',
    target: m
  }, log);

  m[1] = three;
  assertArrayEquals(Object.getObservable([two, three]), m);
  assertNextMutationIs({
    mutation: 'set',
    name: '1',
    target: m
  }, log);
}

function testArrayModelSplice() {
  var zero = {zero: 'zero'};
  var one = {one: 'one'};
  var two = {two: 'two'};
  var three = {three: 'three'};
  var zeroModel = Object.getObservable(zero);
  var oneModel = Object.getObservable(one);
  var twoModel = Object.getObservable(two);
  var threeModel = Object.getObservable(three);

  var arr = [zero, one];
  var m = Object.getObservable(arr);

  var log = new MutationLog();
  Object.observe(m, log);

  m.splice(1, 1, two, three);
  assertArrayEquals([zero, two, three], arr);
  assertArrayEquals([zeroModel, twoModel, threeModel], m);

  assertNextMutationIs({
    mutation: 'splice',
    index: 1,
    deleteCount: 1,
    addCount: 2,
    target: m
  }, log);

  m.splice(0, 1);

  assertArrayEquals([two, three], arr);
  assertArrayEquals([twoModel, threeModel], m);

  assertNextMutationIs({
    mutation: 'splice',
    index: 0,
    deleteCount: 1,
    addCount: 0,
    target: m
  }, log);

  m.splice();
  assertNextMutationIs(undefined, log);

  m.splice(0, 0);
  assertNextMutationIs(undefined, log);

  m.splice(0, -1);
  assertNextMutationIs(undefined, log);

  m.splice(-1, 0, 1.5);
  assertArrayEquals([two, 1.5, three], arr);
  assertArrayEquals([twoModel, 1.5, threeModel], m);

  assertNextMutationIs({
    mutation: 'splice',
    index: 1,
    deleteCount: 0,
    addCount: 1,
    target: m
  }, log);

  m.splice(3, 0, zeroModel);
  assertArrayEquals([two, 1.5, three, zero], arr);
  assertArrayEquals([twoModel, 1.5, threeModel, zeroModel], m);

  assertNextMutationIs({
    mutation: 'splice',
    index: 3,
    deleteCount: 0,
    addCount: 1,
    target: m
  }, log);

 m.splice(0);
 assertNextMutationIs({
   mutation: 'splice',
   index: 0,
   deleteCount: 4,
   addCount: 0,
   target: m
 }, log);
}

function testArrayModelSpliceDeleteTooMany() {

  var arr = ['a', 'b', 'c'];
  var m = Object.getObservable(arr);

  var log = new MutationLog();
  Object.observe(m, log);

  m.splice(2, 3);
  assertArrayEquals(['a', 'b'], m);

  assertNextMutationIs({
    mutation: 'splice',
    index: 2,
    deleteCount: 1,
    addCount: 0,
    target: m
  }, log);
}

function testArrayModelLength() {
  var m = Object.getObservable([0, 1]);
  var log = new MutationLog();
  Object.observe(m, log);

  m.length = 5;
  assertArrayEquals([0, 1, , , ,], m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 2,
    deleteCount: 0,
    addCount: 3,
    target: m
  }, log);

  m.length = 1;
  assertArrayEquals([0], m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 1,
    deleteCount: 4,
    addCount: 0,
    target: m
  }, log);

  m.length = 1;
  assertArrayEquals([0], m);
  assertNextMutationIs({
    mutation: 'set',
    name: 'length',
    target: m
  }, log);
}

function testArrayModelLength() {
  var m = Object.getObservable([0, 1]);

  var log = new MutationLog();
  Object.observe(m, log);

  m.length = 5;
  assertArrayEquals([0, 1, , , ,], m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 2,
    deleteCount: 0,
    addCount: 3,
    target: m
  }, log);

  m.length = 1;
  assertArrayEquals([0], m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 1,
    deleteCount: 4,
    addCount: 0,
    target: m
  }, log);

  m.length = 1;
  assertArrayEquals([0], m);
  assertNextMutationIs({
    mutation: 'set',
    name: 'length',
    target: m
  }, log);
}

function testArrayModelPush() {
  var zero = {zero: 0};
  var one = {one: 1};
  var m = Object.getObservable([zero, one]);

  var log = new MutationLog();
  Object.observe(m, log);

  var two = {two: 2};
  var three = {three: 3};

  m.push(two, three);
  assertArrayEquals(Object.getObservable([zero, one, two, three]), m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 2,
    deleteCount: 0,
    addCount: 2,
    target: m
  }, log);

  m.push();
  assertNextMutationIs(undefined, log);

}

function testArrayModelPop() {
  var zero = {zero: 0};
  var one = {one: 1};
  var m = Object.getObservable([zero, one]);

  var log = new MutationLog();
  Object.observe(m, log);

  assertEquals(Object.getObservable(one), m.pop());
  assertArrayEquals([Object.getObservable(zero)], m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 1,
    deleteCount: 1,
    addCount: 0,
    target: m
  }, log);

  assertEquals(Object.getObservable(zero), m.pop());
  assertArrayEquals([], m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 0,
    deleteCount: 1,
    addCount: 0,
    target: m
  }, log);

  assertUndefined,(m.pop());
  assertArrayEquals([], m);
  assertNextMutationIs(undefined, log);
}

function testArrayModelShift() {
  var zero = {zero: 0};
  var one = {one: 1};
  var m = Object.getObservable([zero, one]);

  var log = new MutationLog();
  Object.observe(m, log);

  assertEquals(Object.getObservable(zero), m.shift());
  assertArrayEquals([Object.getObservable(one)], m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 0,
    deleteCount: 1,
    addCount: 0,
    target: m
  }, log);

  assertEquals(Object.getObservable(one), m.shift());
  assertArrayEquals([], m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 0,
    deleteCount: 1,
    addCount: 0,
    target: m
  }, log);

  assertUndefined,(m.shift());
  assertArrayEquals([], m);
  assertNextMutationIs(undefined, log);
}

function testArrayModelUnshift() {
  var zero = {zero: 0};
  var one = {one: 1};
  var m = Object.getObservable([zero, one]);

  var log = new MutationLog();
  Object.observe(m, log);

  var negOne = {negOne: -1};

  assertEquals(3, m.unshift(negOne));
  assertArrayEquals(Object.getObservable([negOne, zero, one]), m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 0,
    deleteCount: 0,
    addCount: 1,
    target: m
  }, log);

  var negTwo = {negTwo: -2};
  var negThree = {negThree: -3};

  assertEquals(5, m.unshift(negThree, negTwo));
  assertArrayEquals(Object.getObservable([negThree, negTwo, negOne, zero, one]),
                    m);
  assertNextMutationIs({
    mutation: 'splice',
    index: 0,
    deleteCount: 0,
    addCount: 2,
    target: m
  }, log);

  assertUndefined,(m.unshift());
  assertArrayEquals(Object.getObservable([negThree, negTwo, negOne, zero, one]),
                    m);
  assertNextMutationIs(undefined, log);
}

function testArrayModelIndexOf() {
  var zero = {zero: 0};
  var one = {one: 1};
  var m = Object.getObservable([zero, one]);
  var zeroModel = m[0];
  var oneModel = m[1];

  assertEquals(0, m.indexOf(zero));
  assertEquals(0, m.indexOf(zeroModel));
  assertEquals(1, m.indexOf(one));
  assertEquals(1, m.indexOf(oneModel));
  assertEquals(-1, m.indexOf({foo: 'bar'}));
}

</script>
</body>
</html>
