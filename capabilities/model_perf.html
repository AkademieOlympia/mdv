<!DOCTYPE html>
<html>
<!--
Copyright 2011 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<head>
<title>Model Property Access Test</title>
<link rel="stylesheet" href="common_styles.css">
<script src="include.js"></script>
<style>
</style>
</head>
<body>
  <div class="example">
    <h1>Model Property Access Test</h1>
    <div class="content">
      <template instantiate>
        <div>
           <label>Number of nodes:
             <input type="text" value="{{ insertCount | number}}">
           </label>
        </div>
        <div>
            <label>Number of iterations:
              <input value="{{ iterations | number }}">
            </label>
        </div>
        <div>Unproxied: {{ unproxied }}ms</div>
        <div>Proxied: {{ proxied }}ms ({{ factor }}x)</div>

        <button onclick="{{ runTest }}">Run</button>
          <span style="color:red" hidden="{{ iterationsLeft | absent }}">
            {{ iterationsLeft }} remaining...<span>
      </template>
    </div>
  </div>

<script>
// Because noone implements WeakMap right now, we have a lame implementation
// that is O(n) for lookup. By adding __id__ to objects, it allows Model.get()
// to use a plane object for mapping (with constant lookup time), and thus not
// distort the results of this test.
var nodeIdCounter = 1;
function BSTNode(isRoot) {
  this.__id__ = nodeIdCounter++;
  this.value = null;
  this.left = isRoot ? new BSTNode() : null;
  this.right = isRoot ? new BSTNode() : null;
}

BSTNode.prototype = {
  insert: function(value) {
    if (this.value == null) {
      this.value = value;
      this.left = new BSTNode();
      this.right = new BSTNode();
    } else {
      if (value < this.value)
        this.left.insert(value);
      else
        this.right.insert(value);
    }
  },

  traverse: function(callback) {
    if (this.value != null) {
      this.left.traverse(callback);
      callback(this.value);
      this.right.traverse(callback);
    }
  }
}
</script>

<script>
var m = document.body.model = Model.get({
  insertCount: 1000,
  iterations: 25,
  unproxied: 0,
  proxied: 0,
  factor: 0,
  runTest: runTest,
  iterationsLeft: 0
});

var timeout;

function runIteration() {
  timeout = null;
  if (m.iterationsLeft <= 0)
    return;

  // Generate random numbers to insert.
  var maxInt = 10000;
  function newNumber(maxInt) {
    return Math.round(Math.random() * maxInt);
  }
  var numbers = [];
  for (var i = 0; i < m.insertCount; i++) {
    numbers.push(newNumber(maxInt));
  }

  function insertN(useModel) {
    var start = Date.now();
    var root = useModel ? Model.get(new BSTNode()) : new BSTNode();

    numbers.forEach(function(n) {
      root.insert(n);
    });

    var last = 0;
    root.traverse(function checkOrdered(value) {
      if (last > value)
        alert('Fail');
      last = value;
    });

    var end = Date.now();
    return end - start;
  }

  m.unproxied += insertN(false);
  m.proxied += insertN(true);
  m.factor = Math.round(m.proxied * 10 / m.unproxied)/10;
  m.iterationsLeft--;
  timeout = setTimeout(runIteration, 0);
  Model.notifyObservers_();
}

function runTest() {
  if (timeout)
    clearTimeout(timeout)

  // Reset results
  m.unproxied = 0;
  m.proxied = 0;
  m.iterationsLeft = m.iterations;
  runIteration();
}

window.onload = runTest;

</script>
  <div class="comment">
    <h1>Comment</h1>
    <div class="content">
      <template instantiate>
       <p>This is a test of the Model.get() proxy system. This is only a
         test. It measures the relative speed of property access on "plain"
         objects vs. objects that are proxied.</p>
      Do the following, {{ iterations }} times:
        <ol>
          <li>Generate {{ insertCount }} random integers between 0 and
              10000.</li>
          <li>Insert each number into a binary search tree which uses one object
              per inserted number.</li>
          <li>Perform an in-order traversal of the BST ensuring the numbers
              are ordered.</li>
          <li>Repeat (with the same sequence of numbers) steps 2 &amp 3 this
              time using a BST that is proxied via the Model.get() proxy
              wrapper.
        </ol>
      </template>
    </div>
  </div>
</body>
</html>
